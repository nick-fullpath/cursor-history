#!/usr/bin/env bash
# cursor-history â€” Browse, search, and resume Cursor Agent CLI sessions
# https://github.com/nick-fullpath/cursor-history
set -euo pipefail

VERSION="0.3.0"

# â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CURSOR_PROJECTS_DIR="${CURSOR_PROJECTS_DIR:-$HOME/.cursor/projects}"
CACHE_DIR="${CURSOR_HISTORY_CACHE:-$HOME/.cursor-history}"
CACHE_FILE="$CACHE_DIR/sessions.json"
CACHE_TTL=300  # seconds

# Resolve the directory where this script (or its symlink target) lives,
# so we can locate lib/indexer.py regardless of how the user invoked us.
_resolve_script_dir() {
  local src="${BASH_SOURCE[0]}"
  while [[ -L "$src" ]]; do
    local dir
    dir="$(cd -P "$(dirname "$src")" && pwd)"
    src="$(readlink "$src")"
    [[ "$src" != /* ]] && src="$dir/$src"
  done
  cd -P "$(dirname "$src")" && pwd
}
SCRIPT_DIR="$(_resolve_script_dir)"

# Locate lib/indexer.py: try SCRIPT_DIR first (dev/manual install),
# then parent directory (Homebrew Cellar layout: bin/ + lib/)
if [[ -f "$SCRIPT_DIR/lib/indexer.py" ]]; then
  LIB_DIR="$SCRIPT_DIR/lib"
elif [[ -f "$SCRIPT_DIR/../lib/cursor-history/indexer.py" ]]; then
  LIB_DIR="$SCRIPT_DIR/../lib/cursor-history"
elif [[ -f "$SCRIPT_DIR/../lib/indexer.py" ]]; then
  LIB_DIR="$SCRIPT_DIR/../lib"
else
  echo "Error: cannot find lib/indexer.py relative to $SCRIPT_DIR" >&2
  exit 1
fi

# â”€â”€â”€ Terminal formatting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BOLD='\033[1m'  DIM='\033[2m'  RESET='\033[0m'
CYAN='\033[36m' GREEN='\033[32m' YELLOW='\033[33m'
RED='\033[31m'  MAGENTA='\033[35m' BLUE='\033[34m'

set_tab_title() { printf '\033]0;%s\007' "$1"; }

# â”€â”€â”€ Numeric formatting helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

human_size() {
  local bytes="$1"
  if   (( bytes >= 1073741824 )); then printf "%.1fG" "$(bc -l <<< "$bytes / 1073741824")"
  elif (( bytes >= 1048576 ));    then printf "%.1fM" "$(bc -l <<< "$bytes / 1048576")"
  elif (( bytes >= 1024 ));       then printf "%.0fK" "$(bc -l <<< "$bytes / 1024")"
  else printf "%dB" "$bytes"
  fi
}

human_tokens() {
  local t="$1"
  if   (( t >= 1000000 )); then printf "%.1fM" "$(bc -l <<< "$t / 1000000")"
  elif (( t >= 1000 ));    then printf "%.1fk" "$(bc -l <<< "$t / 1000")"
  else printf "%d" "$t"
  fi
}

# â”€â”€â”€ Dependency checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

check_deps() {
  local missing=()
  for cmd in jq fzf python3 bc; do
    command -v "$cmd" &>/dev/null || missing+=("$cmd")
  done
  if (( ${#missing[@]} > 0 )); then
    echo -e "${RED}Error:${RESET} Missing dependencies: ${missing[*]}"
    echo "  Install with: brew install ${missing[*]}"
    exit 1
  fi
}

# â”€â”€â”€ Session index â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_cache_is_fresh() {
  [[ -f "$CACHE_FILE" ]] || return 1

  local cache_mtime
  if [[ "$(uname)" == "Darwin" ]]; then
    cache_mtime=$(stat -f %m "$CACHE_FILE")
  else
    cache_mtime=$(stat -c %Y "$CACHE_FILE")
  fi

  # Invalidate if any project directory was modified after the cache
  local newest_project_mtime=0
  for d in "$CURSOR_PROJECTS_DIR"/*/agent-transcripts; do
    [[ -d "$d" ]] || continue
    local mt
    if [[ "$(uname)" == "Darwin" ]]; then
      mt=$(stat -f %m "$d")
    else
      mt=$(stat -c %Y "$d")
    fi
    (( mt > newest_project_mtime )) && newest_project_mtime=$mt
  done

  (( newest_project_mtime < cache_mtime ))
}

build_index() {
  local force="${1:-false}"

  mkdir -p "$CACHE_DIR"

  if [[ "$force" != "true" ]] && _cache_is_fresh; then
    return 0
  fi

  echo -e "${DIM}Scanning sessions...${RESET}" >&2
  python3 "$LIB_DIR/indexer.py" "$CURSOR_PROJECTS_DIR" "$CACHE_FILE"

  local exit_code=$?
  if [[ $exit_code -ne 0 ]]; then
    echo -e "${RED}Error building index.${RESET}" >&2
    return 1
  fi
}

# â”€â”€â”€ JSON field extraction (avoids N+1 jq calls) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Usage: _jq_extract "$json" field1 field2 ...
# Sets shell variables: _field1, _field2, ...
_jq_extract() {
  local json="$1"; shift
  local fields=("$@")

  local jq_expr=""
  for f in "${fields[@]}"; do
    jq_expr+="(.${f} // \"\"),"
  done
  jq_expr="${jq_expr%,}"  # strip trailing comma

  local IFS=$'\x1f'  # unit separator â€” safe delimiter for field values
  local raw
  raw=$(echo "$json" | jq -r "[$jq_expr] | map(tostring) | join(\"\\u001f\")")

  local i=0
  for val in $raw; do
    eval "_${fields[$i]}=\${val}"
    (( i++ )) || true
  done
  # Handle trailing empty fields that IFS splitting drops
  while (( i < ${#fields[@]} )); do
    eval "_${fields[$i]}=''"
    (( i++ )) || true
  done
}

# â”€â”€â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_list() {
  local filter_workspace="" limit=50 json_output=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -w|--workspace) filter_workspace="$2"; shift 2 ;;
      -n|--limit)     limit="$2"; shift 2 ;;
      --json)         json_output=true; shift ;;
      --rebuild)      build_index true; shift ;;
      -*)
        echo -e "${RED}Unknown option:${RESET} $1"
        echo "Run 'cursor-history help' for usage."
        return 1
        ;;
      *) shift ;;
    esac
  done

  if ! [[ "$limit" =~ ^[0-9]+$ ]]; then
    echo -e "${RED}Error:${RESET} --limit must be a positive integer."
    return 1
  fi

  build_index

  local sessions
  sessions=$(cat "$CACHE_FILE")

  if [[ -n "$filter_workspace" ]]; then
    sessions=$(echo "$sessions" | jq --arg w "$filter_workspace" \
      '[.[] | select(.workspace | contains($w))]')
  fi

  sessions=$(echo "$sessions" | jq ".[:$limit]")

  if [[ "$json_output" == true ]]; then
    echo "$sessions" | jq .
    return
  fi

  local total
  total=$(echo "$sessions" | jq 'length')

  if [[ "$total" == "0" ]]; then
    echo -e "${YELLOW}No sessions found.${RESET}"
    return
  fi

  echo -e "${BOLD}Found $total sessions:${RESET}\n"

  echo "$sessions" | jq -r '
    .[] |
    "\(.date)  \(.id | .[0:8])  \(.messages) msgs  \(.workspace | split("/") | .[-1] // "~")  \(.summary | .[0:80])"
  ' | while IFS= read -r line; do
    echo -e "  ${CYAN}${line:0:16}${RESET}  ${line:18}"
  done
}

cmd_pick() {
  build_index
  set_tab_title "cursor-history"

  local sessions total
  sessions=$(cat "$CACHE_FILE")
  total=$(echo "$sessions" | jq 'length')

  if [[ "$total" == "0" ]]; then
    echo -e "${YELLOW}No sessions found.${RESET}"
    return
  fi

  local fzf_input
  fzf_input=$(echo "$sessions" | jq -r '
    .[] |
    "\(.date)\t\(.id | .[0:8])\t\(.messages) msgs\t\(.workspace | split("/") | .[-1] // "~")\t\(.summary | .[0:100])"
  ')

  local selected
  selected=$(echo "$fzf_input" | fzf \
    --ansi \
    --header "$(echo -e "${BOLD}cursor-history${RESET} â€” $total sessions. Enter=resume  Ctrl-S=stats  Ctrl-D=detail")" \
    --header-first \
    --reverse \
    --border rounded \
    --border-label " Cursor Agent Sessions " \
    --prompt "Filter > " \
    --preview "echo {2} | tr -d ' ' | xargs -I_ID '$0' _preview _ID" \
    --preview-window "right:50%:wrap" \
    --bind "ctrl-s:execute('$0' stats)+abort" \
    --tabstop 4 \
    --delimiter '\t' \
    --with-nth '1,2,3,4,5' \
    --no-mouse \
  ) || return 0

  local short_id
  short_id=$(echo "$selected" | cut -f2 | tr -d ' ')

  local full_id
  full_id=$(echo "$sessions" | jq -r --arg sid "$short_id" \
    'first(.[] | select(.id | startswith($sid))) | .id')

  if [[ -z "$full_id" || "$full_id" == "null" ]]; then
    echo -e "${RED}Session not found.${RESET}"
    return 1
  fi

  cmd_resume "$full_id"
}

cmd_resume() {
  local session_id="${1:-}"

  if [[ -z "$session_id" ]]; then
    echo -e "${RED}Usage:${RESET} cursor-history resume <session-id>"
    return 1
  fi

  build_index

  local session
  session=$(jq --arg sid "$session_id" \
    'first(.[] | select(.id | startswith($sid)))' "$CACHE_FILE")

  if [[ -z "$session" || "$session" == "null" ]]; then
    echo -e "${RED}Session '$session_id' not found.${RESET}"
    return 1
  fi

  _jq_extract "$session" id workspace date summary model total_tokens

  local tab_label
  tab_label="$(basename "$_workspace") â€” ${_summary:0:50}"
  set_tab_title "$tab_label"

  local tokens_display=""
  if (( _total_tokens > 0 )) 2>/dev/null; then
    tokens_display="~$(human_tokens "$_total_tokens") tokens"
  fi

  echo -e "${BOLD}Resuming session:${RESET}"
  echo -e "  ${CYAN}ID:${RESET}        ${_id}"
  echo -e "  ${CYAN}Date:${RESET}      ${_date}"
  echo -e "  ${CYAN}Workspace:${RESET} ${_workspace}"
  [[ -n "$_model" ]]          && echo -e "  ${CYAN}Model:${RESET}     ${_model}"
  [[ -n "$tokens_display" ]]  && echo -e "  ${CYAN}Tokens:${RESET}    ${tokens_display}"
  echo -e "  ${CYAN}Summary:${RESET}   ${_summary:0:120}"
  echo ""

  if [[ -d "$_workspace" ]]; then
    echo -e "${GREEN}â†’${RESET} cd $_workspace && cursor-agent --resume $_id"
    echo ""
    echo "__CURSOR_HISTORY_CD__:${_workspace}:cursor-agent --resume ${_id}"
  else
    echo -e "${YELLOW}Warning:${RESET} Workspace '$_workspace' does not exist."
    echo -e "${GREEN}â†’${RESET} cursor-agent --resume $_id"
    echo ""
    echo "__CURSOR_HISTORY_CD__::cursor-agent --resume ${_id}"
  fi
}

cmd_search() {
  local query="${1:-}"

  if [[ -z "$query" ]]; then
    echo -e "${RED}Usage:${RESET} cursor-history search <query>"
    return 1
  fi

  build_index

  echo -e "${BOLD}Searching for:${RESET} ${CYAN}$query${RESET}\n"

  # Batch grep: collect all transcript paths, grep them in one pass
  local -a match_files=()
  local -A match_counts=()

  while IFS=$'\t' read -r tpath sid; do
    [[ -f "$tpath" ]] || continue
    local hits
    hits=$(grep -Fic "$query" "$tpath" 2>/dev/null || true)
    hits="${hits//[^0-9]/}"
    hits="${hits:-0}"
    if (( hits > 0 )); then
      match_files+=("$sid")
      match_counts["$sid"]=$hits
    fi
  done < <(jq -r '.[] | "\(.transcript_path)\t\(.id)"' "$CACHE_FILE")

  if (( ${#match_files[@]} == 0 )); then
    echo -e "${YELLOW}No sessions match '$query'.${RESET}"
    return
  fi

  # Build results in a single jq call using the matched IDs
  local id_json
  id_json=$(printf '%s\n' "${match_files[@]}" | jq -R . | jq -s .)

  local count_map="{}"
  for sid in "${match_files[@]}"; do
    count_map=$(echo "$count_map" | jq --arg k "$sid" --argjson v "${match_counts[$sid]}" '. + {($k): $v}')
  done

  local results
  results=$(jq --argjson ids "$id_json" --argjson counts "$count_map" '
    [.[] | select(.id as $i | $ids | index($i))] |
    map(. + {match_count: ($counts[.id] // 0)}) |
    sort_by(-.match_count)
  ' "$CACHE_FILE")

  local count
  count=$(echo "$results" | jq 'length')
  echo -e "${GREEN}$count sessions${RESET} contain matches:\n"

  echo "$results" | jq -r '
    .[] |
    "\(.date)\t\(.id | .[0:8])\t\(.match_count) hits\t\(.workspace | split("/") | .[-1] // "~")\t\(.summary | .[0:80])"
  ' | while IFS=$'\t' read -r date id hits ws summary; do
    echo -e "  ${CYAN}${date}${RESET}  ${id}  ${MAGENTA}${hits}${RESET}  ${ws}  ${DIM}${summary}${RESET}"
  done

  echo ""

  # Offer interactive selection if stdout is a terminal
  if [[ -t 1 ]]; then
    local fzf_input
    fzf_input=$(echo "$results" | jq -r '
      .[] |
      "\(.date)\t\(.id | .[0:8])\t\(.match_count) hits\t\(.workspace | split("/") | .[-1] // "~")\t\(.summary | .[0:100])"
    ')

    echo -e "${DIM}Press Enter to pick a session, or Ctrl-C to exit.${RESET}"
    local selected
    selected=$(echo "$fzf_input" | fzf \
      --ansi \
      --header "Search results for: $query" \
      --reverse \
      --border rounded \
      --delimiter '\t' \
      --preview "echo {2} | tr -d ' ' | xargs -I_ID '$0' _preview _ID" \
      --preview-window "right:50%:wrap" \
    ) || return 0

    local short_id
    short_id=$(echo "$selected" | cut -f2 | tr -d ' ')
    local full_id
    full_id=$(echo "$results" | jq -r --arg sid "$short_id" \
      'first(.[] | select(.id | startswith($sid))) | .id')
    cmd_resume "$full_id"
  fi
}

cmd_stats() {
  build_index
  set_tab_title "cursor-history â€” stats"

  local sessions
  sessions=$(cat "$CACHE_FILE")

  # Compute all aggregate stats in a single jq call
  local agg
  agg=$(echo "$sessions" | jq '{
    total:            length,
    total_messages:   ([.[].messages] | add // 0),
    total_tool_calls: ([.[].tool_calls] | add // 0),
    total_size:       ([.[].size] | add // 0),
    total_input_tok:  ([.[].input_tokens // 0] | add // 0),
    total_output_tok: ([.[].output_tokens // 0] | add // 0),
    total_code_edits: ([.[].code_edits // 0] | add // 0),
    num_workspaces:   ([.[].workspace] | unique | length),
    oldest:           (last  | .date // "N/A"),
    newest:           (first | .date // "N/A")
  }')

  _jq_extract "$agg" total total_messages total_tool_calls total_size \
    total_input_tok total_output_tok total_code_edits num_workspaces oldest newest

  local total_tokens=$(( _total_input_tok + _total_output_tok ))

  # Header
  echo ""
  echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
  echo -e "${BOLD}â•‘              cursor-history â€” Stats Dashboard               â•‘${RESET}"
  echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
  echo ""

  echo -e "  ${BOLD}Overview${RESET}"
  echo -e "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo -e "  ${CYAN}Total sessions:${RESET}     $_total"
  echo -e "  ${CYAN}Total messages:${RESET}     $_total_messages"
  echo -e "  ${CYAN}Total tool calls:${RESET}   $_total_tool_calls"
  echo -e "  ${CYAN}Tokens (est.):${RESET}      ~$(human_tokens "$total_tokens") (in: ~$(human_tokens "$_total_input_tok"), out: ~$(human_tokens "$_total_output_tok"))"
  echo -e "  ${CYAN}Code edits:${RESET}         $_total_code_edits"
  echo -e "  ${CYAN}Transcript size:${RESET}    $(human_size "$_total_size")"
  echo -e "  ${CYAN}Workspaces:${RESET}         $_num_workspaces"
  echo -e "  ${CYAN}Date range:${RESET}         $_oldest â†’ $_newest"
  echo ""

  # Model usage breakdown
  local model_stats
  model_stats=$(echo "$sessions" | jq -r '
    [.[] | select(.model != null and .model != "")] |
    group_by(.model) |
    map({model: .[0].model, count: length, tokens: ([.[].total_tokens] | add // 0)}) |
    sort_by(-.count) | .[:10] | .[] |
    "\(.count)\t\(.tokens)\t\(.model)"
  ')

  if [[ -n "$model_stats" ]]; then
    echo -e "  ${BOLD}Models Used${RESET}"
    echo -e "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    while IFS=$'\t' read -r mcount mtokens mname; do
      printf "  ${GREEN}%-40s${RESET} %3s sessions  ~%s tokens\n" \
        "$mname" "$mcount" "$(human_tokens "$mtokens")"
    done <<< "$model_stats"
    echo ""
  fi

  # Sessions per workspace
  echo -e "  ${BOLD}Sessions by Workspace${RESET}"
  echo -e "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

  echo "$sessions" | jq -r '
    group_by(.workspace) |
    map({ws: (.[0].workspace | split("/") | .[-1] // .[-2] // "~"),
         count: length, messages: ([.[].messages] | add), last: .[0].date}) |
    sort_by(-.count) | .[:15] | .[] |
    "\(.count)\t\(.messages)\t\(.last)\t\(.ws)"
  ' | while IFS=$'\t' read -r count msgs last ws; do
    local bar_len=$((count * 2))
    (( bar_len > 40 )) && bar_len=40
    local bar=""
    for ((i=0; i<bar_len; i++)); do bar+="â–ˆ"; done
    printf "  ${GREEN}%-25s${RESET} %3s sessions  %4s msgs  ${DIM}%s${RESET}\n" \
      "$ws" "$count" "$msgs" "$last"
    echo -e "  ${BLUE}${bar}${RESET}"
  done
  echo ""

  # Activity timeline
  echo -e "  ${BOLD}Monthly Activity${RESET}"
  echo -e "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

  echo "$sessions" | jq -r '
    [.[].modified] |
    map(. | todate | .[0:7]) |
    group_by(.) |
    map({month: .[0], count: length}) |
    sort_by(.month) | .[] |
    "\(.month)\t\(.count)"
  ' | while IFS=$'\t' read -r month count; do
    local bar_len=$count
    (( bar_len > 40 )) && bar_len=40
    local bar=""
    for ((i=0; i<bar_len; i++)); do bar+="â–ˆ"; done
    printf "  ${CYAN}%-10s${RESET} %3s sessions  ${MAGENTA}%s${RESET}\n" \
      "$month" "$count" "$bar"
  done
  echo ""

  # Largest sessions
  echo -e "  ${BOLD}Largest Sessions (by messages)${RESET}"
  echo -e "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

  echo "$sessions" | jq -r '
    sort_by(-.messages) | .[:10] | .[] |
    "\(.messages)\t\(.tool_calls)\t\(.total_tokens // 0)\t\(.date)\t\(.id | .[0:8])\t\(.workspace | split("/") | .[-1] // "~")\t\(.summary | .[0:50])"
  ' | while IFS=$'\t' read -r msgs tools tokens date id ws summary; do
    printf "  ${YELLOW}%4s msgs${RESET}  ${DIM}%3s tools${RESET}  %7s tok  ${CYAN}%s${RESET}  %s  %-12s  ${DIM}%s${RESET}\n" \
      "$msgs" "$tools" "~$(human_tokens "$tokens")" "$date" "$id" "$ws" "$summary"
  done
  echo ""
}

cmd_preview() {
  local short_id="${1:-}"

  if ! [[ "$short_id" =~ ^[a-f0-9-]+$ ]]; then
    echo "Invalid session ID"
    return 1
  fi

  build_index 2>/dev/null

  local session
  session=$(jq --arg sid "$short_id" \
    'first(.[] | select(.id | startswith($sid)))' "$CACHE_FILE" 2>/dev/null)

  if [[ -z "$session" || "$session" == "null" ]]; then
    echo "Session not found"
    return
  fi

  _jq_extract "$session" id workspace date messages tool_calls summary \
    transcript_path size input_tokens output_tokens total_tokens model code_edits

  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "  Session: $_id"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  echo "  Date:       $_date"
  echo "  Workspace:  $_workspace"
  [[ -n "$_model" ]]                          && echo "  Model:      $_model"
  echo "  Messages:   $_messages"
  echo "  Tool calls: $_tool_calls"
  if (( _total_tokens > 0 )) 2>/dev/null; then
    echo "  Tokens:     ~$(human_tokens "$_total_tokens") (in: ~$(human_tokens "$_input_tokens"), out: ~$(human_tokens "$_output_tokens"))"
  fi
  (( _code_edits > 0 )) 2>/dev/null          && echo "  Code edits: $_code_edits"
  echo "  Size:       $(human_size "$_size")"
  echo ""
  echo "  First prompt:"
  echo "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo "  $_summary"
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  # Show conversation excerpt
  local ext="${_transcript_path##*.}"
  echo ""
  echo "  Conversation:"
  echo "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

  if [[ "$ext" == "jsonl" ]]; then
    python3 -c "
import sys, json, re
with open(sys.argv[1]) as f:
    for i, line in enumerate(f):
        if i >= 20:
            print('  ... (truncated)')
            break
        try:
            d = json.loads(line)
            role = d.get('role', '?')
            for c in d.get('message', {}).get('content', []):
                if c.get('type') == 'text':
                    text = re.sub(r'<[^>]+>', '', c['text']).strip()
                    text = ' '.join(text.split())[:150]
                    marker = 'â–¶' if role == 'user' else 'â—€'
                    print(f'  {marker} [{role}] {text}')
                    break
        except: pass
" "$_transcript_path" 2>/dev/null
  elif [[ "$ext" == "txt" ]]; then
    python3 -c "
import sys, re
with open(sys.argv[1]) as f:
    text = f.read()
count = 0
for line in text.split('\n'):
    if count >= 20:
        print('  ... (truncated)')
        break
    line = line.strip()
    if line in ('user:', 'assistant:'):
        continue
    if line.startswith('<user_query>') or line.startswith('</user_query>'):
        continue
    if line.startswith('[Tool call]'):
        print(f'  ðŸ”§ {line}')
        count += 1
    elif line and not line.startswith('[Tool result]'):
        text = re.sub(r'<[^>]+>', '', line).strip()
        if text:
            print(f'  {text[:150]}')
            count += 1
" "$_transcript_path" 2>/dev/null
  fi
}

cmd_show() {
  local session_id="${1:-}"

  if [[ -z "$session_id" ]]; then
    echo -e "${RED}Usage:${RESET} cursor-history show <session-id>"
    return 1
  fi

  build_index

  local session
  session=$(jq --arg sid "$session_id" \
    'first(.[] | select(.id | startswith($sid)))' "$CACHE_FILE")

  if [[ -z "$session" || "$session" == "null" ]]; then
    echo -e "${RED}Session '$session_id' not found.${RESET}"
    return 1
  fi

  cmd_preview "$(echo "$session" | jq -r '.id | .[0:8]')"
}

cmd_rebuild() {
  echo -e "${CYAN}Rebuilding session index...${RESET}"
  build_index true
  local total
  total=$(jq 'length' "$CACHE_FILE")
  echo -e "${GREEN}Done.${RESET} Indexed $total sessions."
}

cmd_version() { echo "cursor-history v${VERSION}"; }

cmd_help() {
  cat <<EOF

$(echo -e "${BOLD}cursor-history${RESET}") v${VERSION} â€” Browse, search, and resume Cursor Agent CLI sessions

$(echo -e "${BOLD}USAGE${RESET}")
  cursor-history                  Interactive session picker (default)
  cursor-history list [options]   List all sessions
  cursor-history search <query>   Full-text search across sessions
  cursor-history resume <id>      Resume a session by ID (partial OK)
  cursor-history show <id>        Show session details
  cursor-history stats            Stats dashboard
  cursor-history rebuild          Force-rebuild session index

$(echo -e "${BOLD}LIST OPTIONS${RESET}")
  -w, --workspace <path>   Filter by workspace path
  -n, --limit <n>          Max sessions to show (default: 50)
  --json                   Output as JSON
  --rebuild                Rebuild index before listing

$(echo -e "${BOLD}INTERACTIVE KEYS${RESET}")
  Enter       Resume selected session
  Ctrl-S      Show stats dashboard
  Ctrl-D      Show session detail
  Type        Filter sessions

$(echo -e "${BOLD}SHELL INTEGRATION${RESET}")
  Add to your ~/.zshrc:

    eval "\$(cursor-history init zsh)"

  This enables workspace-aware resume in a new terminal tab.

$(echo -e "${BOLD}ENVIRONMENT${RESET}")
  CURSOR_PROJECTS_DIR     Cursor projects dir (default: ~/.cursor/projects)
  CURSOR_HISTORY_CACHE    Cache directory (default: ~/.cursor-history)

EOF
}

# â”€â”€â”€ Shell integration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_init() {
  local shell="${1:-zsh}"

  case "$shell" in
    zsh|bash)
      cat <<'SHELL_FUNC'
_cursor_history_open_tab() {
  local target_dir="$1"
  local resume_cmd="$2"
  local tab_title="$3"

  # Sanitize tab_title for safe embedding in AppleScript strings:
  # escape backslashes first, then double-quotes
  local safe_title="${tab_title//\\/\\\\}"
  safe_title="${safe_title//\"/\\\"}"

  local full_cmd=""
  if [[ -n "$target_dir" && -d "$target_dir" ]]; then
    full_cmd="cd $(printf '%q' "$target_dir") && "
  fi
  full_cmd+="$resume_cmd"

  local safe_cmd="${full_cmd//\\/\\\\}"
  safe_cmd="${safe_cmd//\"/\\\"}"

  local opened_tab=false

  # macOS: try AppleScript
  if command -v osascript >/dev/null 2>&1; then
    if pgrep -q "iTerm2" 2>/dev/null || [[ -n "${ITERM_SESSION_ID:-}" ]]; then
      osascript <<APPLESCRIPT >/dev/null 2>&1 && opened_tab=true
tell application "iTerm"
  tell current window
    create tab with default profile
    tell current session
      write text "printf '\\033]0;${safe_title}\\007'; ${safe_cmd}"
    end tell
  end tell
end tell
APPLESCRIPT
    fi
    if [[ "$opened_tab" == false ]]; then
      osascript <<APPLESCRIPT >/dev/null 2>&1 && opened_tab=true
tell application "Terminal"
  activate
  do script "printf '\\033]0;${safe_title}\\007'; ${safe_cmd}"
end tell
APPLESCRIPT
    fi
  fi

  # tmux
  if [[ "$opened_tab" == false && -n "${TMUX:-}" ]]; then
    tmux new-window -n "$tab_title" "$SHELL -ic '${full_cmd}'" && opened_tab=true
  fi

  # Fallback: run in current shell
  if [[ "$opened_tab" == false ]]; then
    local -a cmd_parts
    if [[ -n "${ZSH_VERSION:-}" ]]; then
      cmd_parts=(${=resume_cmd})
    else
      read -ra cmd_parts <<< "$resume_cmd"
    fi
    if [[ -n "$target_dir" && -d "$target_dir" ]]; then
      cd "$target_dir" || return 1
    fi
    printf '\033]0;%s\007' "$tab_title"
    "${cmd_parts[@]}"
  fi
}

cursor-history() {
  local output
  output=$(command cursor-history "$@")
  local exit_code=$?

  if echo "$output" | grep -q "^__CURSOR_HISTORY_CD__:"; then
    local directive
    directive=$(echo "$output" | grep "^__CURSOR_HISTORY_CD__:" | head -1)
    local target_dir
    target_dir=$(echo "$directive" | cut -d: -f2)
    local resume_id
    resume_id=$(echo "$directive" | cut -d: -f3-)

    echo "$output" | grep -v "^__CURSOR_HISTORY_CD__:"

    if [[ -n "$resume_id" && "$resume_id" =~ ^cursor-agent\ --resume\ [a-f0-9-]+$ ]]; then
      local tab_title="cursor-agent â€” $(basename "${target_dir:-session}")"
      _cursor_history_open_tab "$target_dir" "$resume_id" "$tab_title"
    elif [[ -n "$resume_id" ]]; then
      echo "cursor-history: refusing to execute unexpected command: $resume_id" >&2
      return 1
    fi
  else
    echo "$output"
  fi

  return $exit_code
}
SHELL_FUNC
      ;;
    *)
      echo "Unsupported shell: $shell"
      echo "Supported: zsh, bash"
      return 1
      ;;
  esac
}

# â”€â”€â”€ Main dispatch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main() {
  local cmd="${1:-}"

  case "$cmd" in
    ""|pick)           check_deps; cmd_pick ;;
    list|ls)           check_deps; shift; cmd_list "$@" ;;
    search|s)          check_deps; shift; cmd_search "$@" ;;
    resume|r)          check_deps; shift; cmd_resume "$@" ;;
    show)              check_deps; shift; cmd_show "$@" ;;
    stats)             check_deps; cmd_stats ;;
    rebuild)           check_deps; cmd_rebuild ;;
    init)              shift; cmd_init "$@" ;;
    _preview)          shift; cmd_preview "$@" ;;
    version|--version|-v) cmd_version ;;
    help|--help|-h)    cmd_help ;;
    *)
      echo -e "${RED}Unknown command:${RESET} $cmd"
      echo "Run 'cursor-history help' for usage."
      exit 1
      ;;
  esac
}

main "$@"
