#!/usr/bin/env bash
# ╔════════════════════════════════════════════════════════════════════════════╗
# ║  cursor-history                                                          ║
# ║  Browse, search, and resume Cursor Agent CLI sessions                    ║
# ║  https://github.com/nick-fullpath/cursor-history                        ║
# ║                                                                          ║
# ║  This is the main CLI entrypoint. It delegates session indexing to       ║
# ║  lib/indexer.py (Python) and uses jq for JSON processing, fzf for the   ║
# ║  interactive picker, and bc for numeric formatting.                      ║
# ║                                                                          ║
# ║  Architecture:                                                           ║
# ║    cursor-history (this file)                                            ║
# ║      ├── Reads/writes ~/.cursor-history/sessions.json (cached index)    ║
# ║      ├── Calls lib/indexer.py to rebuild the index when stale           ║
# ║      ├── Uses jq to query/filter/aggregate session data                 ║
# ║      ├── Uses fzf for the interactive TUI picker                        ║
# ║      └── Emits __CURSOR_HISTORY_CD__ directives for shell integration   ║
# ║                                                                          ║
# ║  Shell integration (eval "$(cursor-history init zsh)"):                  ║
# ║    A wrapper function intercepts the __CURSOR_HISTORY_CD__ directive     ║
# ║    and opens a new terminal tab with cd + cursor-agent --resume.         ║
# ╚════════════════════════════════════════════════════════════════════════════╝
set -euo pipefail

VERSION="0.4.3"

# ─── Configuration ────────────────────────────────────────────────────────────
# These can be overridden via environment variables for testing or custom setups.

CURSOR_PROJECTS_DIR="${CURSOR_PROJECTS_DIR:-$HOME/.cursor/projects}"
CACHE_DIR="${CURSOR_HISTORY_CACHE:-$HOME/.cursor-history}"
CACHE_FILE="$CACHE_DIR/sessions.json"

# ─── Script directory resolution ──────────────────────────────────────────────
# Resolve the real directory of this script, following symlinks. This is needed
# to locate lib/indexer.py whether we're running from a dev checkout, a manual
# install, or a Homebrew Cellar layout.

_resolve_script_dir() {
  local src="${BASH_SOURCE[0]}"
  while [[ -L "$src" ]]; do
    local dir
    dir="$(cd -P "$(dirname "$src")" && pwd)"
    src="$(readlink "$src")"
    [[ "$src" != /* ]] && src="$dir/$src"
  done
  cd -P "$(dirname "$src")" && pwd
}
SCRIPT_DIR="$(_resolve_script_dir)"

# Locate lib/indexer.py across different installation layouts:
#   - Dev/manual:  SCRIPT_DIR/lib/indexer.py
#   - Homebrew:    SCRIPT_DIR/../lib/cursor-history/indexer.py
#   - Flat lib:    SCRIPT_DIR/../lib/indexer.py
if [[ -f "$SCRIPT_DIR/lib/indexer.py" ]]; then
  LIB_DIR="$SCRIPT_DIR/lib"
elif [[ -f "$SCRIPT_DIR/../lib/cursor-history/indexer.py" ]]; then
  LIB_DIR="$SCRIPT_DIR/../lib/cursor-history"
elif [[ -f "$SCRIPT_DIR/../lib/indexer.py" ]]; then
  LIB_DIR="$SCRIPT_DIR/../lib"
else
  echo "Error: cannot find lib/indexer.py relative to $SCRIPT_DIR" >&2
  exit 1
fi

# ─── Platform detection ──────────────────────────────────────────────────────
# Cache the OS name once to avoid forking `uname` repeatedly in loops.

_UNAME="$(uname)"

# ─── Terminal formatting ──────────────────────────────────────────────────────
# ANSI escape codes for consistent colored output across all commands.

BOLD='\033[1m'  DIM='\033[2m'  RESET='\033[0m'
CYAN='\033[36m' GREEN='\033[32m' YELLOW='\033[33m'
RED='\033[31m'  MAGENTA='\033[35m' BLUE='\033[34m'

# Set the terminal tab/window title using the OSC escape sequence.
set_tab_title() { printf '\033]0;%s\007' "$1"; }

# ─── Numeric formatting helpers ──────────────────────────────────────────────

# Format byte counts: 1073741824 → "1.0G", 1048576 → "1.0M", 1024 → "1K"
human_size() {
  local bytes="$1"
  if   (( bytes >= 1073741824 )); then printf "%.1fG" "$(bc -l <<< "$bytes / 1073741824")"
  elif (( bytes >= 1048576 ));    then printf "%.1fM" "$(bc -l <<< "$bytes / 1048576")"
  elif (( bytes >= 1024 ));       then printf "%.0fK" "$(bc -l <<< "$bytes / 1024")"
  else printf "%dB" "$bytes"
  fi
}

# Format token counts: 1500000 → "1.5M", 2500 → "2.5k", 42 → "42"
human_tokens() {
  local t="$1"
  if   (( t >= 1000000 )); then printf "%.1fM" "$(bc -l <<< "$t / 1000000")"
  elif (( t >= 1000 ));    then printf "%.1fk" "$(bc -l <<< "$t / 1000")"
  else printf "%d" "$t"
  fi
}

# Render a horizontal bar chart segment. Caps at max_len characters.
_bar() {
  local len="$1"
  local max_len="${2:-40}"
  (( len > max_len )) && len=$max_len
  local bar=""
  for ((i=0; i<len; i++)); do bar+="█"; done
  printf '%s' "$bar"
}

# ─── Dependency checks ───────────────────────────────────────────────────────

check_deps() {
  local missing=()
  for cmd in jq fzf python3 bc; do
    command -v "$cmd" &>/dev/null || missing+=("$cmd")
  done
  if (( ${#missing[@]} > 0 )); then
    echo -e "${RED}Error:${RESET} Missing dependencies: ${missing[*]}"
    echo "  Install with: brew install ${missing[*]}"
    exit 1
  fi
}

# ─── Platform-aware stat helper ───────────────────────────────────────────────

_file_mtime() {
  if [[ "$_UNAME" == "Darwin" ]]; then
    stat -f %m "$1"
  else
    stat -c %Y "$1"
  fi
}

# ─── Session index (cache management) ────────────────────────────────────────
# The session index is a JSON array cached at ~/.cursor-history/sessions.json.
# It's rebuilt by lib/indexer.py when stale. Staleness is determined by comparing
# the cache file's mtime against the newest agent-transcripts directory mtime.

_cache_is_fresh() {
  [[ -f "$CACHE_FILE" ]] || return 1

  local cache_mtime
  cache_mtime=$(_file_mtime "$CACHE_FILE")

  local newest_project_mtime=0
  for d in "$CURSOR_PROJECTS_DIR"/*/agent-transcripts; do
    [[ -d "$d" ]] || continue
    local mt
    mt=$(_file_mtime "$d")
    (( mt > newest_project_mtime )) && newest_project_mtime=$mt
  done

  (( newest_project_mtime < cache_mtime ))
}

# Build (or rebuild) the session index by invoking lib/indexer.py.
# Skips the rebuild if the cache is still fresh, unless force=true.
# Note: under set -e, a non-zero exit from python3 will abort the script
# immediately, which is the desired behavior for a fatal indexing failure.
build_index() {
  local force="${1:-false}"

  mkdir -p "$CACHE_DIR"

  if [[ "$force" != "true" ]] && _cache_is_fresh; then
    return 0
  fi

  echo -e "${DIM}Scanning sessions...${RESET}" >&2
  python3 "$LIB_DIR/indexer.py" "$CURSOR_PROJECTS_DIR" "$CACHE_FILE"
}

# ─── JSON field extraction ────────────────────────────────────────────────────
# Extracts multiple fields from a JSON object in a single jq call, avoiding
# the N+1 problem of calling jq once per field. Results are stored in shell
# variables prefixed with underscore (e.g., field "id" → variable $_id).
#
# Uses the ASCII Unit Separator (0x1f) as a delimiter between field values,
# which is safe because it never appears in normal text content.
#
# Usage:
#   _jq_extract "$json_string" id workspace date summary
#   echo "$_id"        # → "a1b2c3d4-..."
#   echo "$_workspace" # → "/Users/jane/my-api"

_jq_extract() {
  local json="$1"; shift
  local fields=("$@")

  local jq_expr=""
  for f in "${fields[@]}"; do
    jq_expr+="(.${f} // \"\"),"
  done
  jq_expr="${jq_expr%,}"

  local raw
  raw=$(echo "$json" | jq -j "[$jq_expr] | map(tostring) | join(\"\\u001f\")")

  # Split on Unit Separator (0x1f) using read -d.
  # This avoids eval entirely, preventing shell metacharacter injection.
  # The trailing 0x1f ensures the last field is captured by the while loop.
  local -a values=()
  local val
  while IFS= read -r -d $'\x1f' val; do
    values+=("$val")
  done <<< "${raw}${raw:+$'\x1f'}"

  local i
  for (( i=0; i < ${#fields[@]}; i++ )); do
    printf -v "_${fields[$i]}" '%s' "${values[$i]:-}"
  done
}

# ─── Commands ─────────────────────────────────────────────────────────────────

# ── list: Display sessions as a formatted table ──────────────────────────────

cmd_list() {
  local filter_workspace="" limit=50 json_output=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -w|--workspace) filter_workspace="$2"; shift 2 ;;
      -n|--limit)     limit="$2"; shift 2 ;;
      --json)         json_output=true; shift ;;
      --rebuild)      build_index true; shift ;;
      -*)
        echo -e "${RED}Unknown option:${RESET} $1"
        echo "Run 'cursor-history help' for usage."
        return 1
        ;;
      *)
        echo -e "${RED}Unexpected argument:${RESET} $1"
        echo "Run 'cursor-history help' for usage."
        return 1
        ;;
    esac
  done

  if ! [[ "$limit" =~ ^[0-9]+$ ]]; then
    echo -e "${RED}Error:${RESET} --limit must be a positive integer."
    return 1
  fi

  build_index

  local sessions
  sessions=$(cat "$CACHE_FILE")

  if [[ -n "$filter_workspace" ]]; then
    sessions=$(echo "$sessions" | jq --arg w "$filter_workspace" \
      '[.[] | select(.workspace | contains($w))]')
  fi

  sessions=$(echo "$sessions" | jq ".[:$limit]")

  if [[ "$json_output" == true ]]; then
    echo "$sessions" | jq .
    return
  fi

  local total
  total=$(echo "$sessions" | jq 'length')

  if [[ "$total" == "0" ]]; then
    echo -e "${YELLOW}No sessions found.${RESET}"
    return
  fi

  echo -e "${BOLD}Found $total sessions:${RESET}\n"

  echo "$sessions" | jq -r '
    .[] |
    "\(.date)  \(.id | .[0:8])  \(.messages) msgs  \(.workspace | split("/") | .[-1] // "~")  \(.summary | .[0:80])"
  ' | while IFS= read -r line; do
    echo -e "  ${CYAN}${line:0:16}${RESET}  ${line:18}"
  done
}

# ── pick: Interactive session picker (default command) ────────────────────────

cmd_pick() {
  build_index
  set_tab_title "cursor-history"

  local sessions total
  sessions=$(cat "$CACHE_FILE")
  total=$(echo "$sessions" | jq 'length')

  if [[ "$total" == "0" ]]; then
    echo -e "${YELLOW}No sessions found.${RESET}"
    return
  fi

  local fzf_input
  fzf_input=$(echo "$sessions" | jq -r '
    .[] |
    "\(.date)\t\(.id | .[0:8])\t\(.messages) msgs\t\(.workspace | split("/") | .[-1] // "~")\t\(.summary | .[0:100])"
  ')

  local selected
  selected=$(echo "$fzf_input" | fzf \
    --ansi \
    --header "$(echo -e "${BOLD}cursor-history${RESET} — $total sessions. Enter=resume")" \
    --header-first \
    --reverse \
    --border rounded \
    --border-label " Cursor Agent Sessions " \
    --prompt "Filter > " \
    --preview "echo {2} | tr -d ' ' | xargs -I_ID '$0' _preview _ID" \
    --preview-window "right:50%:wrap" \
    --tabstop 4 \
    --delimiter '\t' \
    --with-nth '1,2,3,4,5' \
    --no-mouse \
  ) || return 0

  local short_id
  short_id=$(echo "$selected" | cut -f2 | tr -d ' ')

  local full_id
  full_id=$(echo "$sessions" | jq -r --arg sid "$short_id" \
    'first(.[] | select(.id | startswith($sid))) | .id')

  if [[ -z "$full_id" || "$full_id" == "null" ]]; then
    echo -e "${RED}Session not found.${RESET}"
    return 1
  fi

  cmd_resume "$full_id"
}

# ── resume: Resume a session by full or partial ID ───────────────────────────
# Emits a __CURSOR_HISTORY_CD__ directive for the shell integration wrapper.
#
# NOTE: The directive uses ':' as a delimiter. Workspace paths containing ':'
# (rare but valid on macOS/Linux) would cause incorrect parsing in the shell
# wrapper's `cut -d:` calls. This is a known limitation.

cmd_resume() {
  local session_id="${1:-}"

  if [[ -z "$session_id" ]]; then
    echo -e "${RED}Usage:${RESET} cursor-history resume <session-id>"
    return 1
  fi

  if ! [[ "$session_id" =~ ^[a-f0-9-]+$ ]]; then
    echo -e "${RED}Error:${RESET} Invalid session ID (expected hex/UUID)."
    return 1
  fi

  build_index

  local session
  session=$(jq --arg sid "$session_id" \
    'first(.[] | select(.id | startswith($sid)))' "$CACHE_FILE")

  if [[ -z "$session" || "$session" == "null" ]]; then
    echo -e "${RED}Session '$session_id' not found.${RESET}"
    return 1
  fi

  _jq_extract "$session" id workspace date summary model total_tokens

  local tab_label
  tab_label="$(basename "$_workspace") — ${_summary:0:50}"
  set_tab_title "$tab_label"

  local tokens_display=""
  if (( _total_tokens > 0 )) 2>/dev/null; then
    tokens_display="~$(human_tokens "$_total_tokens") tokens"
  fi

  echo -e "${BOLD}Resuming session:${RESET}"
  echo -e "  ${CYAN}ID:${RESET}        ${_id}"
  echo -e "  ${CYAN}Date:${RESET}      ${_date}"
  echo -e "  ${CYAN}Workspace:${RESET} ${_workspace}"
  [[ -n "$_model" ]]          && echo -e "  ${CYAN}Model:${RESET}     ${_model}"
  [[ -n "$tokens_display" ]]  && echo -e "  ${CYAN}Tokens:${RESET}    ${tokens_display}"
  echo -e "  ${CYAN}Summary:${RESET}   ${_summary:0:120}"
  echo ""

  if [[ -d "$_workspace" ]]; then
    echo -e "${GREEN}→${RESET} cd $_workspace && cursor-agent --resume $_id"
    echo ""
    echo "__CURSOR_HISTORY_CD__:${_workspace}:cursor-agent --resume ${_id}"
  else
    echo -e "${YELLOW}Warning:${RESET} Workspace '$_workspace' does not exist."
    echo -e "${GREEN}→${RESET} cursor-agent --resume $_id"
    echo ""
    echo "__CURSOR_HISTORY_CD__::cursor-agent --resume ${_id}"
  fi
}

# ── search: Full-text search across all transcript files ─────────────────────

cmd_search() {
  local query="${1:-}"

  if [[ -z "$query" ]]; then
    echo -e "${RED}Usage:${RESET} cursor-history search <query>"
    return 1
  fi

  build_index

  echo -e "${BOLD}Searching for:${RESET} ${CYAN}$query${RESET}\n"

  # Phase 1: Grep each transcript file for the query string
  local -a match_files=()
  local -A match_counts=()

  while IFS=$'\t' read -r tpath sid; do
    [[ -f "$tpath" ]] || continue
    local hits
    hits=$(grep -Fic "$query" "$tpath" 2>/dev/null || true)
    hits="${hits//[^0-9]/}"
    hits="${hits:-0}"
    if (( hits > 0 )); then
      match_files+=("$sid")
      match_counts["$sid"]=$hits
    fi
  done < <(jq -r '.[] | "\(.transcript_path)\t\(.id)"' "$CACHE_FILE")

  if (( ${#match_files[@]} == 0 )); then
    echo -e "${YELLOW}No sessions match '$query'.${RESET}"
    return
  fi

  # Phase 2: Build the count_map as JSON in a single jq call instead of N calls
  local id_json
  id_json=$(printf '%s\n' "${match_files[@]}" | jq -R . | jq -s .)

  local -a count_pairs=()
  for sid in "${match_files[@]}"; do
    count_pairs+=("$(printf '"%s":%d' "$sid" "${match_counts[$sid]}")")
  done
  local count_map
  count_map=$(printf '{%s}' "$(IFS=,; echo "${count_pairs[*]}")")

  local results
  results=$(jq --argjson ids "$id_json" --argjson counts "$count_map" '
    [.[] | select(.id as $i | $ids | index($i))] |
    map(. + {match_count: ($counts[.id] // 0)}) |
    sort_by(-.match_count)
  ' "$CACHE_FILE")

  local count
  count=$(echo "$results" | jq 'length')
  echo -e "${GREEN}$count sessions${RESET} contain matches:\n"

  echo "$results" | jq -r '
    .[] |
    "\(.date)\t\(.id | .[0:8])\t\(.match_count) hits\t\(.workspace | split("/") | .[-1] // "~")\t\(.summary | .[0:80])"
  ' | while IFS=$'\t' read -r date id hits ws summary; do
    echo -e "  ${CYAN}${date}${RESET}  ${id}  ${MAGENTA}${hits}${RESET}  ${ws}  ${DIM}${summary}${RESET}"
  done

  echo ""

  if [[ -t 1 ]]; then
    local fzf_input
    fzf_input=$(echo "$results" | jq -r '
      .[] |
      "\(.date)\t\(.id | .[0:8])\t\(.match_count) hits\t\(.workspace | split("/") | .[-1] // "~")\t\(.summary | .[0:100])"
    ')

    echo -e "${DIM}Press Enter to pick a session, or Ctrl-C to exit.${RESET}"
    local selected
    selected=$(echo "$fzf_input" | fzf \
      --ansi \
      --header "Search results for: $query" \
      --reverse \
      --border rounded \
      --delimiter '\t' \
      --preview "echo {2} | tr -d ' ' | xargs -I_ID '$0' _preview _ID" \
      --preview-window "right:50%:wrap" \
    ) || return 0

    local short_id
    short_id=$(echo "$selected" | cut -f2 | tr -d ' ')
    local full_id
    full_id=$(echo "$results" | jq -r --arg sid "$short_id" \
      'first(.[] | select(.id | startswith($sid))) | .id')
    cmd_resume "$full_id"
  fi
}

# ── stats: Usage statistics dashboard ─────────────────────────────────────────

cmd_stats() {
  build_index
  set_tab_title "cursor-history — stats"

  local sessions
  sessions=$(cat "$CACHE_FILE")

  local agg
  agg=$(echo "$sessions" | jq '{
    total:            length,
    total_messages:   ([.[].messages] | add // 0),
    total_tool_calls: ([.[].tool_calls] | add // 0),
    total_size:       ([.[].size] | add // 0),
    total_input_tok:  ([.[].input_tokens // 0] | add // 0),
    total_output_tok: ([.[].output_tokens // 0] | add // 0),
    total_code_edits: ([.[].code_edits // 0] | add // 0),
    num_workspaces:   ([.[].workspace] | unique | length),
    oldest:           (last  | .date // "N/A"),
    newest:           (first | .date // "N/A")
  }')

  _jq_extract "$agg" total total_messages total_tool_calls total_size \
    total_input_tok total_output_tok total_code_edits num_workspaces oldest newest

  local total_tokens=$(( _total_input_tok + _total_output_tok ))

  echo ""
  echo -e "${BOLD}╔══════════════════════════════════════════════════════════════╗${RESET}"
  echo -e "${BOLD}║              cursor-history — Stats Dashboard               ║${RESET}"
  echo -e "${BOLD}╚══════════════════════════════════════════════════════════════╝${RESET}"
  echo ""

  echo -e "  ${BOLD}Overview${RESET}"
  echo -e "  ────────────────────────────────────────"
  echo -e "  ${CYAN}Total sessions:${RESET}     $_total"
  echo -e "  ${CYAN}Total messages:${RESET}     $_total_messages"
  echo -e "  ${CYAN}Total tool calls:${RESET}   $_total_tool_calls"
  echo -e "  ${CYAN}Tokens (est.):${RESET}      ~$(human_tokens "$total_tokens") (in: ~$(human_tokens "$_total_input_tok"), out: ~$(human_tokens "$_total_output_tok"))"
  echo -e "  ${CYAN}Code edits:${RESET}         $_total_code_edits"
  echo -e "  ${CYAN}Transcript size:${RESET}    $(human_size "$_total_size")"
  echo -e "  ${CYAN}Workspaces:${RESET}         $_num_workspaces"
  echo -e "  ${CYAN}Date range:${RESET}         $_oldest → $_newest"
  echo ""

  local model_stats
  model_stats=$(echo "$sessions" | jq -r '
    [.[] | select(.model != null and .model != "")] |
    group_by(.model) |
    map({model: .[0].model, count: length, tokens: ([.[].total_tokens] | add // 0)}) |
    sort_by(-.count) | .[:10] | .[] |
    "\(.count)\t\(.tokens)\t\(.model)"
  ')

  if [[ -n "$model_stats" ]]; then
    echo -e "  ${BOLD}Models Used${RESET}"
    echo -e "  ────────────────────────────────────────"
    while IFS=$'\t' read -r mcount mtokens mname; do
      printf "  ${GREEN}%-40s${RESET} %3s sessions  ~%s tokens\n" \
        "$mname" "$mcount" "$(human_tokens "$mtokens")"
    done <<< "$model_stats"
    echo ""
  fi

  echo -e "  ${BOLD}Sessions by Workspace${RESET}"
  echo -e "  ────────────────────────────────────────"

  echo "$sessions" | jq -r '
    group_by(.workspace) |
    map({ws: (.[0].workspace | split("/") | .[-1] // .[-2] // "~"),
         count: length, messages: ([.[].messages] | add), last: .[0].date}) |
    sort_by(-.count) | .[:15] | .[] |
    "\(.count)\t\(.messages)\t\(.last)\t\(.ws)"
  ' | while IFS=$'\t' read -r count msgs last ws; do
    printf "  ${GREEN}%-25s${RESET} %3s sessions  %4s msgs  ${DIM}%s${RESET}\n" \
      "$ws" "$count" "$msgs" "$last"
    echo -e "  ${BLUE}$(_bar $((count * 2)))${RESET}"
  done
  echo ""

  echo -e "  ${BOLD}Monthly Activity${RESET}"
  echo -e "  ────────────────────────────────────────"

  echo "$sessions" | jq -r '
    [.[].modified] |
    map(. | todate | .[0:7]) |
    group_by(.) |
    map({month: .[0], count: length}) |
    sort_by(.month) | .[] |
    "\(.month)\t\(.count)"
  ' | while IFS=$'\t' read -r month count; do
    printf "  ${CYAN}%-10s${RESET} %3s sessions  ${MAGENTA}%s${RESET}\n" \
      "$month" "$count" "$(_bar "$count")"
  done
  echo ""

  echo -e "  ${BOLD}Largest Sessions (by messages)${RESET}"
  echo -e "  ────────────────────────────────────────"

  echo "$sessions" | jq -r '
    sort_by(-.messages) | .[:10] | .[] |
    "\(.messages)\t\(.tool_calls)\t\(.total_tokens // 0)\t\(.date)\t\(.id | .[0:8])\t\(.workspace | split("/") | .[-1] // "~")\t\(.summary | .[0:50])"
  ' | while IFS=$'\t' read -r msgs tools tokens date id ws summary; do
    printf "  ${YELLOW}%4s msgs${RESET}  ${DIM}%3s tools${RESET}  %7s tok  ${CYAN}%s${RESET}  %s  %-12s  ${DIM}%s${RESET}\n" \
      "$msgs" "$tools" "~$(human_tokens "$tokens")" "$date" "$id" "$ws" "$summary"
  done
  echo ""
}

# ── preview: Internal command used by fzf's --preview ─────────────────────────
# Renders a detailed view of a single session for the fzf preview pane.
# Delegates conversation rendering to lib/indexer.py --preview.

cmd_preview() {
  local short_id="${1:-}"

  if ! [[ "$short_id" =~ ^[a-f0-9-]+$ ]]; then
    echo "Invalid session ID"
    return 1
  fi

  build_index 2>/dev/null

  local session
  session=$(jq --arg sid "$short_id" \
    'first(.[] | select(.id | startswith($sid)))' "$CACHE_FILE" 2>/dev/null)

  if [[ -z "$session" || "$session" == "null" ]]; then
    echo "Session not found"
    return
  fi

  _jq_extract "$session" id workspace date messages tool_calls summary \
    transcript_path size input_tokens output_tokens total_tokens model code_edits

  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo "  Session: $_id"
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""
  echo "  Date:       $_date"
  echo "  Workspace:  $_workspace"
  [[ -n "$_model" ]]                          && echo "  Model:      $_model"
  echo "  Messages:   $_messages"
  echo "  Tool calls: $_tool_calls"
  if (( _total_tokens > 0 )) 2>/dev/null; then
    echo "  Tokens:     ~$(human_tokens "$_total_tokens") (in: ~$(human_tokens "$_input_tokens"), out: ~$(human_tokens "$_output_tokens"))"
  fi
  (( _code_edits > 0 )) 2>/dev/null          && echo "  Code edits: $_code_edits"
  echo "  Size:       $(human_size "$_size")"
  echo ""
  echo "  First prompt:"
  echo "  ─────────────"
  echo "  $_summary"
  echo ""
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""
  echo "  Conversation:"
  echo "  ─────────────"

  python3 "$LIB_DIR/indexer.py" --preview "$_transcript_path" 20 2>/dev/null
}

# ── show: Display detailed session info ───────────────────────────────────────
# Delegates directly to cmd_preview, passing the user's ID argument.
# cmd_preview handles the lookup internally, so no double jq call is needed.

cmd_show() {
  local session_id="${1:-}"

  if [[ -z "$session_id" ]]; then
    echo -e "${RED}Usage:${RESET} cursor-history show <session-id>"
    return 1
  fi

  cmd_preview "$session_id"
}

# ── rebuild: Force-rebuild the session index ──────────────────────────────────

cmd_rebuild() {
  echo -e "${CYAN}Rebuilding session index...${RESET}"
  build_index true
  local total
  total=$(jq 'length' "$CACHE_FILE")
  echo -e "${GREEN}Done.${RESET} Indexed $total sessions."
}

# ── version / help ────────────────────────────────────────────────────────────

cmd_version() { echo "cursor-history v${VERSION}"; }

cmd_help() {
  cat <<EOF

$(echo -e "${BOLD}cursor-history${RESET}") v${VERSION} — Browse, search, and resume Cursor Agent CLI sessions

$(echo -e "${BOLD}USAGE${RESET}")
  cursor-history                  Interactive session picker (default)
  cursor-history list [options]   List all sessions
  cursor-history search <query>   Full-text search across sessions
  cursor-history resume <id>      Resume a session by ID (partial OK)
  cursor-history show <id>        Show session details
  cursor-history stats            Stats dashboard
  cursor-history rebuild          Force-rebuild session index

$(echo -e "${BOLD}LIST OPTIONS${RESET}")
  -w, --workspace <path>   Filter by workspace path
  -n, --limit <n>          Max sessions to show (default: 50)
  --json                   Output as JSON
  --rebuild                Rebuild index before listing

$(echo -e "${BOLD}INTERACTIVE KEYS${RESET}")
  Enter       Resume selected session
  Type        Filter sessions

$(echo -e "${BOLD}SHELL INTEGRATION${RESET}")
  Add to your ~/.zshrc:

    eval "\$(cursor-history init zsh)"

  This enables workspace-aware resume in a new terminal tab.

$(echo -e "${BOLD}ENVIRONMENT${RESET}")
  CURSOR_PROJECTS_DIR     Cursor projects dir (default: ~/.cursor/projects)
  CURSOR_HISTORY_CACHE    Cache directory (default: ~/.cursor-history)

EOF
}

# ─── Shell integration ────────────────────────────────────────────────────────
# Generates a shell function that wraps the `cursor-history` binary. When the
# binary emits a __CURSOR_HISTORY_CD__ directive (from cmd_resume), the wrapper
# intercepts it and opens a new terminal tab with the appropriate cd + resume.
#
# The wrapper is installed by the user adding this to their shell rc file:
#   eval "$(cursor-history init zsh)"
#
# Security: The wrapper validates the resume command against an allowlist regex
# before executing it, and sanitizes strings before embedding in AppleScript.

cmd_init() {
  local shell="${1:-zsh}"

  case "$shell" in
    zsh|bash)
      cat <<'SHELL_FUNC'
# Opens a new terminal tab/window and runs the given command in it.
# Supports iTerm2, Apple Terminal, and tmux. Falls back to current shell.
_cursor_history_open_tab() {
  local target_dir="$1"
  local resume_cmd="$2"
  local tab_title="$3"

  # Sanitize strings for safe embedding in AppleScript double-quoted strings.
  local safe_title="${tab_title//\\/\\\\}"
  safe_title="${safe_title//\"/\\\"}"

  local full_cmd=""
  if [[ -n "$target_dir" && -d "$target_dir" ]]; then
    full_cmd="cd $(printf '%q' "$target_dir") && "
  fi
  full_cmd+="$resume_cmd"

  local safe_cmd="${full_cmd//\\/\\\\}"
  safe_cmd="${safe_cmd//\"/\\\"}"

  local opened_tab=false

  if command -v osascript >/dev/null 2>&1; then
    if pgrep -q "iTerm2" 2>/dev/null || [[ -n "${ITERM_SESSION_ID:-}" ]]; then
      osascript <<APPLESCRIPT >/dev/null 2>&1 && opened_tab=true
tell application "iTerm"
  tell current window
    create tab with default profile
    tell current session
      write text "printf '\\033]0;${safe_title}\\007'; ${safe_cmd}"
    end tell
  end tell
end tell
APPLESCRIPT
    fi
    if [[ "$opened_tab" == false ]]; then
      osascript <<APPLESCRIPT >/dev/null 2>&1 && opened_tab=true
tell application "Terminal"
  activate
  do script "printf '\\033]0;${safe_title}\\007'; ${safe_cmd}"
end tell
APPLESCRIPT
    fi
  fi

  if [[ "$opened_tab" == false && -n "${TMUX:-}" ]]; then
    tmux new-window -n "$tab_title" "$SHELL -ic '${full_cmd}'" && opened_tab=true
  fi

  if [[ "$opened_tab" == false ]]; then
    local -a cmd_parts
    if [[ -n "${ZSH_VERSION:-}" ]]; then
      cmd_parts=(${=resume_cmd})
    else
      read -ra cmd_parts <<< "$resume_cmd"
    fi
    if [[ -n "$target_dir" && -d "$target_dir" ]]; then
      cd "$target_dir" || return 1
    fi
    printf '\033]0;%s\007' "$tab_title"
    "${cmd_parts[@]}"
  fi
}

# Shell wrapper for cursor-history. Intercepts __CURSOR_HISTORY_CD__ directives
# from the binary's stdout and converts them into actual shell actions.
cursor-history() {
  local output
  output=$(command cursor-history "$@")
  local exit_code=$?

  if echo "$output" | grep -q "^__CURSOR_HISTORY_CD__:"; then
    local directive
    directive=$(echo "$output" | grep "^__CURSOR_HISTORY_CD__:" | head -1)
    local target_dir
    target_dir=$(echo "$directive" | cut -d: -f2)
    local resume_id
    resume_id=$(echo "$directive" | cut -d: -f3-)

    echo "$output" | grep -v "^__CURSOR_HISTORY_CD__:"

    if [[ -n "$resume_id" && "$resume_id" =~ ^cursor-agent\ --resume\ [a-f0-9-]+$ ]]; then
      local tab_title="cursor-agent — $(basename "${target_dir:-session}")"
      _cursor_history_open_tab "$target_dir" "$resume_id" "$tab_title"
    elif [[ -n "$resume_id" ]]; then
      echo "cursor-history: refusing to execute unexpected command: $resume_id" >&2
      return 1
    fi
  else
    echo "$output"
  fi

  return $exit_code
}
SHELL_FUNC
      ;;
    *)
      echo "Unsupported shell: $shell"
      echo "Supported: zsh, bash"
      return 1
      ;;
  esac
}

# ─── Main dispatch ────────────────────────────────────────────────────────────
# Routes the first argument to the appropriate command function.
# Aliases: ls→list, s→search, r→resume. The default (no args) opens the picker.

main() {
  local cmd="${1:-}"

  case "$cmd" in
    ""|pick)           check_deps; cmd_pick ;;
    list|ls)           check_deps; shift; cmd_list "$@" ;;
    search|s)          check_deps; shift; cmd_search "$@" ;;
    resume|r)          check_deps; shift; cmd_resume "$@" ;;
    show)              check_deps; shift; cmd_show "$@" ;;
    stats)             check_deps; cmd_stats ;;
    rebuild)           check_deps; cmd_rebuild ;;
    init)              shift; cmd_init "$@" ;;
    _preview)          shift; cmd_preview "$@" ;;
    version|--version|-v) cmd_version ;;
    help|--help|-h)    cmd_help ;;
    *)
      echo -e "${RED}Unknown command:${RESET} $cmd"
      echo "Run 'cursor-history help' for usage."
      exit 1
      ;;
  esac
}

main "$@"
